#!/bin/sh
# =========================================================
# ImmortalWRT Portal Agent (runtime bootstrapper)
#
# Runs on ImmortalWRT (data-plane).
# - Fetches policy/runtime from ap-controller (control-plane, VM)
# - Generates /tmp/portal-runtime.env (atomic)
# - Optionally triggers portal-fw.sh to apply dataplane rules
#
# Requirements (ImmortalWrt): curl, jsonfilter, logger
# =========================================================

set -eu

TAG="portal-agent"

# -------- user-tunable defaults (can be overridden by env) --------
CTRL_HOST="${CTRL_HOST:-192.168.16.118}"
CTRL_PORT="${CTRL_PORT:-8443}"
CTRL_BASE="${CTRL_BASE:-http://${CTRL_HOST}:${CTRL_PORT}}"

# Runtime endpoint (Go controller). We keep a fallback to legacy paths.
RUNTIME_PATH="${RUNTIME_PATH:-/api/v1/policy/runtime}"
RUNTIME_LEGACY_PATH="${RUNTIME_LEGACY_PATH:-/policy/runtime}"

# Identify this AP (optional but recommended)
AP_ID="${AP_ID:-$(cat /proc/sys/kernel/hostname 2>/dev/null || echo ap-unknown)}"
SITE_ID="${SITE_ID:-default}"
RADIO_ID="${RADIO_ID:-radio0}"

# Where to write runtime env
RUNTIME_ENV="${RUNTIME_ENV:-/tmp/portal-runtime.env}"

# If set to 1, apply dataplane right after refreshing runtime
APPLY_FW="${APPLY_FW:-1}"
PORTAL_FW="${PORTAL_FW:-/mnt/portal-fw.sh}"

log() {
  logger -t "$TAG" "$*"
}

# Write env file atomically
write_env_atomic() {
  tmp="${RUNTIME_ENV}.tmp.$$"
  umask 077
  cat >"$tmp"
  mv -f "$tmp" "$RUNTIME_ENV"
}

# Best-effort fetch helper (returns body on stdout, non-zero on error)
http_get() {
  url="$1"
  curl -fsS --max-time 3 "$url"
}

log "event=runtime_fetch_start ctrl=${CTRL_BASE} ap_id=${AP_ID} site=${SITE_ID} radio=${RADIO_ID}"

# Try new endpoint first
RESP="$(http_get "${CTRL_BASE}${RUNTIME_PATH}?site=${SITE_ID}&ap_id=${AP_ID}&radio_id=${RADIO_ID}" 2>/dev/null || true)"
if [ -z "$RESP" ]; then
  RESP="$(http_get "${CTRL_BASE}${RUNTIME_LEGACY_PATH}?site=${SITE_ID}&ap_id=${AP_ID}&radio_id=${RADIO_ID}" 2>/dev/null || true)"
fi

if [ -z "$RESP" ]; then
  log "event=runtime_fetch_failed reason=curl"
  exit 1
fi

# Parse fields (schema is defined by controller; we are defensive)
POLICY_VERSION="$(printf '%s' "$RESP" | jsonfilter -e '@.policy.version' 2>/dev/null || true)"
[ -n "$POLICY_VERSION" ] || POLICY_VERSION="$(printf '%s' "$RESP" | jsonfilter -e '@.policy_version' 2>/dev/null || true)"
[ -n "$POLICY_VERSION" ] || POLICY_VERSION="0"

LAN_IF="$(printf '%s' "$RESP" | jsonfilter -e '@.dataplane.lan_if' 2>/dev/null || true)"
[ -n "$LAN_IF" ] || LAN_IF="br-lan"

PORTAL_IP="$(printf '%s' "$RESP" | jsonfilter -e '@.dataplane.portal_ip' 2>/dev/null || true)"
[ -n "$PORTAL_IP" ] || PORTAL_IP="$CTRL_HOST"

DNS_PORT="$(printf '%s' "$RESP" | jsonfilter -e '@.dataplane.dns_port' 2>/dev/null || true)"
[ -n "$DNS_PORT" ] || DNS_PORT="53"

# default ipset names (the controller may return a map)
# Expect: dataplane.ipsets.allow.guest / staff ...
IPSET_GUEST="$(printf '%s' "$RESP" | jsonfilter -e '@.dataplane.ipsets.allow.guest' 2>/dev/null || true)"
IPSET_STAFF="$(printf '%s' "$RESP" | jsonfilter -e '@.dataplane.ipsets.allow.staff' 2>/dev/null || true)"
[ -n "$IPSET_GUEST" ] || IPSET_GUEST="portal_allow_guest"
[ -n "$IPSET_STAFF" ] || IPSET_STAFF="portal_allow_staff"

# bypass lists
BYPASS_MACS="$(printf '%s' "$RESP" | jsonfilter -e '@.bypass.mac_whitelist' 2>/dev/null || true)"
BYPASS_IPS="$(printf '%s' "$RESP" | jsonfilter -e '@.bypass.ip_whitelist' 2>/dev/null || true)"
BYPASS_DOMAINS="$(printf '%s' "$RESP" | jsonfilter -e '@.bypass.domains' 2>/dev/null || true)"
BYPASS_ENABLED="$(printf '%s' "$RESP" | jsonfilter -e '@.bypass.enabled' 2>/dev/null || true)"
[ -n "$BYPASS_ENABLED" ] || BYPASS_ENABLED="true"

# Persist runtime env (shell-friendly exports)
write_env_atomic <<EOF
# Auto-generated by portal-agent.sh at $(date -Iseconds)
export CTRL_BASE='${CTRL_BASE}'
export POLICY_VERSION='${POLICY_VERSION}'
export AP_ID='${AP_ID}'
export SITE_ID='${SITE_ID}'
export RADIO_ID='${RADIO_ID}'

# Dataplane
export LAN_IF='${LAN_IF}'
export PORTAL_IP='${PORTAL_IP}'
export DNS_PORT='${DNS_PORT}'

# ipsets (roles -> allow sets)
export IPSET_GUEST='${IPSET_GUEST}'
export IPSET_STAFF='${IPSET_STAFF}'

# bypass (raw JSON arrays as strings; scripts may parse further)
export BYPASS_ENABLED='${BYPASS_ENABLED}'
export BYPASS_MACS='${BYPASS_MACS}'
export BYPASS_IPS='${BYPASS_IPS}'
export BYPASS_DOMAINS='${BYPASS_DOMAINS}'
EOF

log "event=runtime_fetch_done policy_version=${POLICY_VERSION} lan_if=${LAN_IF} portal_ip=${PORTAL_IP} ipset_guest=${IPSET_GUEST} ipset_staff=${IPSET_STAFF}"

# Optionally apply dataplane rules
if [ "$APPLY_FW" = "1" ] && [ -x "$PORTAL_FW" ]; then
  log "event=apply_fw_start script=${PORTAL_FW}"
  if "$PORTAL_FW"; then
    log "event=apply_fw_done"
  else
    log "event=apply_fw_failed"
    exit 2
  fi
fi

exit 0