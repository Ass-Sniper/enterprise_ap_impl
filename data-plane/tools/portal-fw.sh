#!/bin/sh
# =========================================================
# ImmortalWRT Captive Portal data-plane init script
#
# Runs on ImmortalWRT (data-plane).
# - Loads /tmp/portal-runtime.env (generated by portal-agent.sh)
# - Creates ipsets for allowed MACs (per role/profile)
# - Installs iptables rules:
#     * DNS hijack (PREROUTING/nat) for unauthorized clients
#     * Forwarding gate (filter) allowing:
#         - authorized MACs
#         - traffic to portal/controller IPs
#
# Logs are written to syslog and can be read via:
#   logread -e portal-fw
# =========================================================

set -eu

RUNTIME_ENV="${RUNTIME_ENV:-/tmp/portal-runtime.env}"
LOG_TAG="${LOG_TAG:-portal-fw}"

# Defaults (used if runtime env is missing/partial)
LAN_IF="${LAN_IF:-br-lan}"
PORTAL_IP="${PORTAL_IP:-192.168.16.118}"
PORTAL_PORT="${PORTAL_PORT:-8080}"
DNS_PORT="${DNS_PORT:-53}"

# ipset names (may be overridden by runtime env)
IPSET_GUEST="${IPSET_GUEST:-portal_allow_guest}"
IPSET_STAFF="${IPSET_STAFF:-portal_allow_staff}"
IPSET_BYPASS_MAC="${IPSET_BYPASS_MAC:-portal_bypass_mac}"
IPSET_BYPASS_IP="${IPSET_BYPASS_IP:-portal_bypass_ip}"
IPSET_BYPASS_DNS="${IPSET_BYPASS_DNS:-portal_bypass_dns}"

# chains
CHAIN_DNS="${CHAIN_DNS:-PORTAL_DNS}"
CHAIN_FWD="${CHAIN_FWD:-PORTAL_FWD}"
CHAIN_HTTP="${CHAIN_HTTP:-PORTAL_HTTP}"

log() { logger -t "$LOG_TAG" "$*"; }

# Load runtime env (generated on ImmortalWRT by portal-agent.sh)
if [ -f "$RUNTIME_ENV" ]; then
  # shellcheck disable=SC1090
  . "$RUNTIME_ENV" || true
fi

# Ensure variables exist after sourcing
LAN_IF="${LAN_IF:-br-lan}"
PORTAL_IP="${PORTAL_IP:-192.168.16.118}"
PORTAL_PORT="${PORTAL_PORT:-8080}"
DNS_PORT="${DNS_PORT:-53}"
IPSET_GUEST="${IPSET_GUEST:-portal_allow_guest}"
IPSET_STAFF="${IPSET_STAFF:-portal_allow_staff}"
IPSET_BYPASS_MAC="${IPSET_BYPASS_MAC:-portal_bypass_mac}"
IPSET_BYPASS_IP="${IPSET_BYPASS_IP:-portal_bypass_ip}"
IPSET_BYPASS_DNS="${IPSET_BYPASS_DNS:-portal_bypass_dns}"

log "event=init_start lan_if=${LAN_IF} portal_ip=${PORTAL_IP} dns_port=${DNS_PORT}"

# ---------------------------------------------------------
# 1) ipsets: Function to create a MAC-based ipset with version compatibility
# ---------------------------------------------------------
ensure_ipset_mac() {
  name="$1"

  # Check if ipset already exists. This avoids redundancy and simplifies the logic.
  if ipset list "$name" >/dev/null 2>&1; then
    log "event=ipset_exists name=${name}"
    return 0
  fi

  log "event=ipset_creating name=${name} type=hash:mac"

  # --- Compatibility Attempts (Try newest syntax first, fall back) ---

  # 1. Attempt using ipset v7.x compliant syntax (Option: timeout, Value: 0).
  # 'timeout 0' sets the default timeout to 0 (permanent), but critically enables
  # per-entry timeout handling for later 'ipset add' commands in portal-agent.sh.
  # This specifically fixes the 'Missing mandatory argument' error.
  if ipset create "$name" hash:mac timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v7.x_compliant"
    return 0
  fi

  # 2. Fallback: Attempt using ipset v6.x syntax (Option: --timeout, Value: 0).
  # Some older versions of ipset require the -- prefix for create options.
  if ipset create "$name" hash:mac --timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v6.x_compliant"
    return 0
  fi

  # 3. Last Fallback: Attempt creating the set without any timeout option.
  # This provides basic MAC filtering functionality for very old ipset versions
  # that might not support the timeout extension at all.
  if ipset create "$name" hash:mac 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=no_timeout"
    return 0
  fi

  # If all attempts fail, log a critical error and exit the script.
  log "error=ipset_create_failed name=${name} msg='All ipset creation attempts failed. Check ipset version/support.'"
  exit 1
}

# Create an IP-based ipset (hash:ip)
ensure_ipset_ip() {
  name="$1"

  if ipset list "$name" >/dev/null 2>&1; then
    log "event=ipset_exists name=${name}"
    return 0
  fi

  log "event=ipset_creating name=${name} type=hash:ip"

  if ipset create "$name" hash:ip timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v7.x_compliant"
    return 0
  fi

  if ipset create "$name" hash:ip --timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v6.x_compliant"
    return 0
  fi

  if ipset create "$name" hash:ip 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=no_timeout"
    return 0
  fi

  log "error=ipset_create_failed name=${name} type=hash:ip"
  exit 1
}

assert_ipset_hash_mac() {
  name="$1"
  if ipset list "$name" >/dev/null 2>&1; then
    if ! ipset list "$name" | grep -q "Type: hash:mac"; then
      log "level=error event=ipset_type_mismatch name=${name} expect=hash:mac"
      exit 1
    fi
  fi
}

assert_ipset_hash_ip() {
  name="$1"
  if ipset list "$name" >/dev/null 2>&1; then
    if ! ipset list "$name" | grep -q "Type: hash:ip"; then
      log "level=error event=ipset_type_mismatch name=${name} expect=hash:ip"
      exit 1
    fi
  fi
}

# normalize_domain
#
# Normalize domain names for dnsmasq ipset rules.
#
# Why this is required:
# - dnsmasq ipset uses suffix matching, NOT glob patterns
# - "*.example.com" is WRONG for dnsmasq
# - Correct form is "example.com"
#
# This function:
# - trims leading/trailing whitespace
# - strips leading "*." (glob-style wildcard)
# - strips leading "." (common misconfiguration)
# - returns empty string for invalid input
#
# Examples:
#   "*.microsoft.com" -> "microsoft.com"
#   ".apple.com"      -> "apple.com"
#   "google.com"      -> "google.com"
#
normalize_domain() {
  d="$1"

  # trim whitespace
  d="$(echo "$d" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

  # strip leading "*."
  d="${d#*.}"

  # strip leading "."
  d="${d#.}"

  # basic sanity check (must contain at least one dot)
  case "$d" in
    *.*) echo "$d" ;;
    *)   echo "" ;;
  esac
}

# ---------------------------------------------------------
# ipset_count
#
# Count the number of entries in an ipset in a robust way.
#
# Why this helper exists:
# - `ipset list` output is NOT a stable API
# - Member lines may not always start with digits
#   (e.g. IPv6 addresses, formatting differences)
# - grep-based counting (e.g. ^[0-9]) is unreliable
#
# This function:
# - Parses the section AFTER the "Members:" line
# - Counts only non-empty member lines
# - Works consistently across:
#     * IPv4 / IPv6
#     * different ipset versions
#     * BusyBox / full ipset
#
# Args:
#   $1: ipset name
#
# Output:
#   Prints the number of members to stdout
#   Prints 0 if the ipset is empty or missing members
#
# Notes:
# - Errors from `ipset list` are suppressed
# - This function is intended for logging / auditing,
#   not for control-flow decisions
# ---------------------------------------------------------
ipset_count() {
  ipset list "$1" 2>/dev/null \
    | awk '/Members:/ {f=1; next} f && NF {c++} END {print c+0}'
}

# =========================================================
# DNS dataplane constants (GLOBAL)
# =========================================================
DNSMASQ_IPSET_DIR="/tmp/dnsmasq.d"
DNSMASQ_IPSET_CONF="${DNSMASQ_IPSET_DIR}/portal-bypass-ipset.conf"

# ---------------------------------------------------------
# reconcile_ipset
#
# Reconcile an ipset to match the desired runtime state
# (runtime-authoritative, flush-and-rebuild semantics).
#
# Why this helper exists:
# - ipsets are stateful and persist across script runs
# - incremental "add-only" updates lead to stale entries
# - controller / runtime must be the single source of truth
#
# This function enforces a strict reconcile model:
#   1. Ensure the target ipset exists
#   2. Count and flush existing entries
#   3. Validate and parse the runtime JSON array
#   4. Rebuild the ipset by invoking a caller-provided
#      add-callback for each runtime element
#   5. Log before/after state for auditability
#
# Design notes:
# - The ipset output format is NOT treated as an API
# - Counting is done via the "Members:" section only
# - JSON parsing uses `printf | jq` for deterministic behavior
# - The add operation itself is delegated to a callback,
#   allowing policy-specific behavior (MAC / IP / variants)
#
# What this function does NOT do:
# - It does not create ipsets or change their types
# - It does not apply timeouts or expiration policies
# - It does not handle multi-layer models (e.g. DNS + ipset)
#
# Typical usage:
#   reconcile_ipset \
#     "$IPSET_BYPASS_IP" \
#     "bypass_ip" \
#     "$BYPASS_IPS" \
#     add_bypass_ip
#
# Args:
#   $1: ipset name
#   $2: logical label for logging (e.g. "bypass_ip")
#   $3: runtime JSON array string (or empty / null)
#   $4: add-callback function name
#
# Behavior with empty runtime:
# - The ipset is flushed
# - No entries are added
# - The final count is logged as 0
#
# Error handling:
# - Missing ipset or invalid JSON is logged as an error
# - The function returns non-zero on fatal validation errors
# - Partial rebuilds are avoided by validating JSON upfront
#
# Intended scope:
# - Dataplane reconciliation and audit logging
# - Not intended as a generic ipset manipulation library
# ---------------------------------------------------------
reconcile_ipset() {
  _set="$1"
  _label="$2"
  _json="$3"
  _add_fn="$4"

  if ! ipset list "$_set" >/dev/null 2>&1; then
    log "level=error event=${_label}_ipset_missing name=${_set}"
    return 1
  fi

  _before="$(ipset_count "$_set")"
  # Best-effort flush (ignore transient ipset v7.x errors: ipset v7.6: Internal protocol error)
  ipset flush "$_set" 2>/dev/null || true
  log "event=${_label}_flush count_before=${_before}"

  if [ -z "$_json" ] || [ "$_json" = "null" ]; then
    log "event=${_label}_skip reason=empty_runtime"
    log "event=${_label}_apply_done count_after=0"
    return 0
  fi

  if ! printf '%s' "$_json" | jq -e 'type=="array"' >/dev/null 2>&1; then
    log "level=error event=${_label}_parse_failed raw=${_json}"
    return 1
  fi

  printf '%s' "$_json" | jq -r '.[]' | while IFS= read -r item; do
    [ -n "$item" ] || continue
    "$_add_fn" "$item"
  done

  _after="$(ipset_count "$_set")"
  log "event=${_label}_apply_done count_after=${_after}"
}

add_bypass_mac() {
  mac="$1"
  ipset -exist add "$IPSET_BYPASS_MAC" "$mac" timeout 0 || true
  log "event=bypass_ctrl_mac mac=${mac}"
}

add_bypass_ip() {
  ip="$1"
  ipset -exist add "$IPSET_BYPASS_IP" "$ip" timeout 0 || true
  log "event=bypass_ctrl_ip ip=${ip}"
}

add_bypass_domain() {
  raw="$1"
  domain="$(normalize_domain "$raw")"
  [ -n "$domain" ] || return 0

  echo "ipset=/${domain}/${IPSET_BYPASS_DNS}" >> "$DNSMASQ_IPSET_CONF"
  log "event=bypass_ctrl_domain domain=${domain}"
}


ensure_ipset_mac "$IPSET_GUEST"
assert_ipset_hash_mac "$IPSET_GUEST"
ensure_ipset_mac "$IPSET_STAFF"
assert_ipset_hash_mac "$IPSET_STAFF"
ensure_ipset_mac "$IPSET_BYPASS_MAC"
assert_ipset_hash_mac "$IPSET_BYPASS_MAC"
ensure_ipset_ip  "$IPSET_BYPASS_IP"
assert_ipset_hash_ip "$IPSET_BYPASS_IP"
ensure_ipset_ip  "$IPSET_BYPASS_DNS"   # Domains are ultimately resolved to IPs
assert_ipset_hash_ip "$IPSET_BYPASS_DNS"

# ---------------------------------------------------------
# 1.1) Bypass MAC reconcile
# ---------------------------------------------------------
SELF_MAC="$(cat /sys/class/net/"${LAN_IF}"/address 2>/dev/null || true)"
if [ -n "$SELF_MAC" ]; then
  ipset -exist add "$IPSET_BYPASS_MAC" "$SELF_MAC" timeout 0 || true
  log "event=bypass_self_mac mac=${SELF_MAC}"
fi

if [ "${BYPASS_ENABLED:-false}" = "true" ]; then
  reconcile_ipset \
    "$IPSET_BYPASS_MAC" \
    "bypass_mac" \
    "$BYPASS_MACS" \
    add_bypass_mac
else
  reconcile_ipset \
    "$IPSET_BYPASS_MAC" \
    "bypass_mac" \
    "" \
    :
fi

# ---------------------------------------------------------
# 1.2) Bypass IP reconcile
# ---------------------------------------------------------
if [ "${BYPASS_ENABLED:-false}" = "true" ]; then
  reconcile_ipset \
    "$IPSET_BYPASS_IP" \
    "bypass_ip" \
    "$BYPASS_IPS" \
    add_bypass_ip
else
  reconcile_ipset \
    "$IPSET_BYPASS_IP" \
    "bypass_ip" \
    "" \
    :
fi

# ---------------------------------------------------------
# 1.3) DNS bypass reconcile (two-layer model)
# ---------------------------------------------------------
# 1.3.1) Result layer: flush DNS ipset (runtime authoritative)
reconcile_ipset \
  "$IPSET_BYPASS_DNS" \
  "bypass_dns" \
  "" \
  :

# 1.3.2) Source layer: rebuild dnsmasq ipset rules
mkdir -p "$DNSMASQ_IPSET_DIR"
# Truncates (or creates if missing) the file referenced by $DNSMASQ_IPSET_CONF
# using the no-op ":" command, effectively clearing its contents to an empty file without writing any data.
: > "$DNSMASQ_IPSET_CONF"
log "event=bypass_dns_conf_rebuild_start"

if [ "${BYPASS_ENABLED:-false}" = "true" ]; then
  reconcile_ipset \
    "$IPSET_BYPASS_DNS" \
    "bypass_dns_conf" \
    "${BYPASS_DOMAINS:-}" \
    add_bypass_domain
fi

# 1.3.3) Reload dnsmasq to apply rule source
if /etc/init.d/dnsmasq reload 2>/dev/null; then
  log "event=dnsmasq_reloaded reason=bypass_domains"
elif /etc/init.d/dnsmasq restart 2>/dev/null; then
  log "event=dnsmasq_restarted reason=bypass_domains"
else
  log "level=error event=dnsmasq_reload_failed reason=bypass_domains"
fi

# 1.3.4) Observe final state (result layer)
COUNT_AFTER="$(ipset_count "$IPSET_BYPASS_DNS")"
log "event=bypass_dns_apply_done count_after=${COUNT_AFTER}"

# ---------------------------------------------------------
# 2) NAT: HTTP captive portal (PREROUTING)
# ---------------------------------------------------------
if ! iptables -t nat -L "$CHAIN_HTTP" >/dev/null 2>&1; then
  iptables -t nat -N "$CHAIN_HTTP"
  log "event=chain_created table=nat chain=${CHAIN_HTTP}"
fi

# Hook PREROUTING -> CHAIN_HTTP (LAN only, TCP/80)
if ! iptables -t nat -C PREROUTING -p tcp --dport 80 -j "$CHAIN_HTTP" >/dev/null 2>&1; then
  # Insert after DNS hook (DNS is at position 1)
  iptables -t nat -I PREROUTING 2 -p tcp --dport 80 -j "$CHAIN_HTTP"
  log "event=chain_hooked table=nat hook=PREROUTING chain=${CHAIN_HTTP} proto=tcp dport=80"
fi

# Rebuild HTTP portal chain (reconcile semantics)
iptables -t nat -F "$CHAIN_HTTP"

# Authorized clients -> RETURN
iptables -t nat -A "$CHAIN_HTTP" -m set --match-set "$IPSET_GUEST" src -j RETURN
iptables -t nat -A "$CHAIN_HTTP" -m set --match-set "$IPSET_STAFF" src -j RETURN

# Bypass MACs -> RETURN
iptables -t nat -A "$CHAIN_HTTP" -m set --match-set "$IPSET_BYPASS_MAC" src -j RETURN

# Bypass IPs (dst) -> RETURN
iptables -t nat -A "$CHAIN_HTTP" -m set --match-set "$IPSET_BYPASS_IP" dst -j RETURN

# Unauthenticated HTTP -> DNAT to portal
iptables -t nat -A "$CHAIN_HTTP" \
  -p tcp --dport 80 \
  -j DNAT --to-destination "${PORTAL_IP}:${PORTAL_PORT}"

# Stop further NAT processing after portal DNAT
iptables -t nat -A "$CHAIN_HTTP" -j RETURN

log "event=http_portal_rules_installed chain=${CHAIN_HTTP} to=${PORTAL_IP}:${PORTAL_PORT}"

# ---------------------------------------------------------
# 2.1) NAT: HTTP portal SNAT (POSTROUTING)
# ---------------------------------------------------------
# Ensure reply packets return via router (avoid TCP RST)
if ! iptables -t nat -C POSTROUTING \
    -d "$PORTAL_IP" -p tcp --dport "$PORTAL_PORT" \
    -j MASQUERADE 2>/dev/null; then
  iptables -t nat -A POSTROUTING \
    -d "$PORTAL_IP" -p tcp --dport "$PORTAL_PORT" \
    -j MASQUERADE
  log "event=http_portal_snat_installed dst=${PORTAL_IP}:${PORTAL_PORT}"
fi

# ---------------------------------------------------------
# 3) NAT: DNS hijack chain
# ---------------------------------------------------------
if ! iptables -t nat -L "$CHAIN_DNS" >/dev/null 2>&1; then
  iptables -t nat -N "$CHAIN_DNS"
  log "event=chain_created table=nat chain=${CHAIN_DNS}"
fi

# Hook PREROUTING -> CHAIN_DNS (LAN only)
if ! iptables -t nat -C PREROUTING -j "$CHAIN_DNS" >/dev/null 2>&1; then
  iptables -t nat -I PREROUTING 1 -j "$CHAIN_DNS"
  log "event=chain_hooked table=nat hook=PREROUTING chain=${CHAIN_DNS} in=${LAN_IF}"
fi

# Rebuild rules
iptables -t nat -F "$CHAIN_DNS"

# Authorized clients (any allow ipset) -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_GUEST" src -j RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_STAFF" src -j RETURN

# Bypass MACs -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_BYPASS_MAC" src -j RETURN
# Bypass IPs -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_BYPASS_IP" dst -j RETURN
# Bypass Domains -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_BYPASS_DNS" dst -j RETURN

# Hijack DNS to portal IP
iptables -t nat -A "$CHAIN_DNS" -p udp --dport 53 -j DNAT --to-destination "${PORTAL_IP}:${DNS_PORT}"
iptables -t nat -A "$CHAIN_DNS" -p tcp --dport 53 -j DNAT --to-destination "${PORTAL_IP}:${DNS_PORT}"

iptables -t nat -A "$CHAIN_DNS" -j RETURN
log "event=dns_rules_installed chain=${CHAIN_DNS}"

# ---------------------------------------------------------
# 4) FILTER: forwarding control chain
# ---------------------------------------------------------
if ! iptables -L "$CHAIN_FWD" >/dev/null 2>&1; then
  iptables -N "$CHAIN_FWD"
  log "event=chain_created table=filter chain=${CHAIN_FWD}"
fi

# Hook lan forwarding custom chain (fw3) -> CHAIN_FWD
# (Your fw3 chain already exists: forwarding_lan_rule)
if ! iptables -C forwarding_lan_rule -j "$CHAIN_FWD" >/dev/null 2>&1; then
  iptables -I forwarding_lan_rule 1 -j "$CHAIN_FWD"
  log "event=chain_hooked table=filter hook=forwarding_lan_rule chain=${CHAIN_FWD}"
fi

iptables -F "$CHAIN_FWD"

# Allow authorized MACs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_GUEST" src -j ACCEPT
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_STAFF" src -j ACCEPT

# Allow bypass MACs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_BYPASS_MAC" src -j ACCEPT
# Allow bypass IPs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_BYPASS_IP" dst -j ACCEPT
# Allow bypass Domains (domain-based bypass via DNS -> ipset)
# CRITICAL FIX: The following rule must be disabled to ensure captive portal detection.
# Reason: Allowing forward traffic for $IPSET_BYPASS_DNS lets OS probes (e.g., Windows NCSI) 
# reach the internet directly. When the client receives a '200 OK' from Microsoft instead 
# of a '302 Redirect' from our portal, the login popup will NOT be triggered.
#
# iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_BYPASS_DNS" dst -j ACCEPT


# Always allow reaching portal/controller IP (for login/heartbeat)
iptables -A "$CHAIN_FWD" -d "$PORTAL_IP" -j ACCEPT

# ---------------------------------------------------------
# HTTPS captive portal assist:
# For unauthenticated clients, actively reject HTTPS (443)
# to trigger OS captive-portal fallback to HTTP.
# ---------------------------------------------------------
iptables -A "$CHAIN_FWD" \
  -p tcp --dport 443 \
  -j REJECT --reject-with tcp-reset
log "event=https_block_installed dport=443 action=tcp-reset"

# Block everything else
iptables -A "$CHAIN_FWD" -j REJECT --reject-with icmp-port-unreachable

log "event=init_done"
exit 0