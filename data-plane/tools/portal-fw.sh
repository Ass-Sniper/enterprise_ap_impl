#!/bin/sh
# =========================================================
# ImmortalWRT Captive Portal data-plane init script
#
# Runs on ImmortalWRT (data-plane).
# - Loads /tmp/portal-runtime.env (generated by portal-agent.sh)
# - Creates ipsets for allowed MACs (per role/profile)
# - Installs iptables rules:
#     * DNS hijack (PREROUTING/nat) for unauthorized clients
#     * Forwarding gate (filter) allowing:
#         - authorized MACs
#         - traffic to portal/controller IPs
#
# Logs are written to syslog and can be read via:
#   logread -e portal-fw
# =========================================================

set -eu

RUNTIME_ENV="${RUNTIME_ENV:-/tmp/portal-runtime.env}"
LOG_TAG="${LOG_TAG:-portal-fw}"

# Defaults (used if runtime env is missing/partial)
LAN_IF="${LAN_IF:-br-lan}"
PORTAL_IP="${PORTAL_IP:-192.168.16.118}"
DNS_PORT="${DNS_PORT:-53}"

# ipset names (may be overridden by runtime env)
IPSET_GUEST="${IPSET_GUEST:-portal_allow_guest}"
IPSET_STAFF="${IPSET_STAFF:-portal_allow_staff}"
IPSET_BYPASS="${IPSET_BYPASS:-portal_bypass_mac}"

# chains
CHAIN_DNS="${CHAIN_DNS:-PORTAL_DNS}"
CHAIN_FWD="${CHAIN_FWD:-PORTAL_FWD}"

log() { logger -t "$LOG_TAG" "$*"; }

# Load runtime env (generated on ImmortalWRT by portal-agent.sh)
if [ -f "$RUNTIME_ENV" ]; then
  # shellcheck disable=SC1090
  . "$RUNTIME_ENV" || true
fi

# Ensure variables exist after sourcing
LAN_IF="${LAN_IF:-br-lan}"
PORTAL_IP="${PORTAL_IP:-192.168.16.118}"
DNS_PORT="${DNS_PORT:-53}"
IPSET_GUEST="${IPSET_GUEST:-portal_allow_guest}"
IPSET_STAFF="${IPSET_STAFF:-portal_allow_staff}"
IPSET_BYPASS="${IPSET_BYPASS:-portal_bypass_mac}"

log "event=init_start lan_if=${LAN_IF} portal_ip=${PORTAL_IP} dns_port=${DNS_PORT}"

# ---------------------------------------------------------
# 1) ipsets
# ---------------------------------------------------------
ensure_ipset() {
  name="$1"
  if ! ipset list "$name" >/dev/null 2>&1; then
    # Use per-entry timeout (timeout 0 in header)
    ipset create "$name" hash:mac timeout
    log "event=ipset_created name=${name}"
  else
    log "event=ipset_exists name=${name}"
  fi
}

ensure_ipset "$IPSET_GUEST"
ensure_ipset "$IPSET_STAFF"
ensure_ipset "$IPSET_BYPASS"

# Always bypass self MAC (bridge MAC) to avoid locking out the router itself
SELF_MAC="$(cat /sys/class/net/${LAN_IF}/address 2>/dev/null || true)"
if [ -n "$SELF_MAC" ]; then
  ipset -exist add "$IPSET_BYPASS" "$SELF_MAC" timeout 0 || true
  log "event=bypass_self_mac mac=${SELF_MAC}"
fi

# ---------------------------------------------------------
# 2) NAT: DNS hijack chain
# ---------------------------------------------------------
if ! iptables -t nat -L "$CHAIN_DNS" >/dev/null 2>&1; then
  iptables -t nat -N "$CHAIN_DNS"
  log "event=chain_created table=nat chain=${CHAIN_DNS}"
fi

# Hook PREROUTING -> CHAIN_DNS (LAN only)
if ! iptables -t nat -C PREROUTING -i "$LAN_IF" -j "$CHAIN_DNS" >/dev/null 2>&1; then
  iptables -t nat -I PREROUTING 1 -i "$LAN_IF" -j "$CHAIN_DNS"
  log "event=chain_hooked table=nat hook=PREROUTING chain=${CHAIN_DNS} in=${LAN_IF}"
fi

# Rebuild rules
iptables -t nat -F "$CHAIN_DNS"

# Authorized clients (any allow ipset) -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_GUEST" src -j RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_STAFF" src -j RETURN

# Bypass MACs -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_BYPASS" src -j RETURN

# Hijack DNS to portal IP
iptables -t nat -A "$CHAIN_DNS" -p udp --dport 53 -j DNAT --to-destination "${PORTAL_IP}:${DNS_PORT}"
iptables -t nat -A "$CHAIN_DNS" -p tcp --dport 53 -j DNAT --to-destination "${PORTAL_IP}:${DNS_PORT}"

iptables -t nat -A "$CHAIN_DNS" -j RETURN
log "event=dns_rules_installed chain=${CHAIN_DNS}"

# ---------------------------------------------------------
# 3) FILTER: forwarding control chain
# ---------------------------------------------------------
if ! iptables -L "$CHAIN_FWD" >/dev/null 2>&1; then
  iptables -N "$CHAIN_FWD"
  log "event=chain_created table=filter chain=${CHAIN_FWD}"
fi

# Hook lan forwarding custom chain (fw3) -> CHAIN_FWD
# (Your fw3 chain already exists: forwarding_lan_rule)
if ! iptables -C forwarding_lan_rule -j "$CHAIN_FWD" >/dev/null 2>&1; then
  iptables -I forwarding_lan_rule 1 -j "$CHAIN_FWD"
  log "event=chain_hooked table=filter hook=forwarding_lan_rule chain=${CHAIN_FWD}"
fi

iptables -F "$CHAIN_FWD"

# Allow authorized MACs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_GUEST" src -j ACCEPT
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_STAFF" src -j ACCEPT

# Allow bypass MACs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_BYPASS" src -j ACCEPT

# Always allow reaching portal/controller IP (for login/heartbeat)
iptables -A "$CHAIN_FWD" -d "$PORTAL_IP" -j ACCEPT

# Block everything else
iptables -A "$CHAIN_FWD" -j REJECT --reject-with icmp-port-unreachable

log "event=init_done"
exit 0