#!/bin/sh
# =========================================================
# ImmortalWRT Captive Portal data-plane init script
#
# Runs on ImmortalWRT (data-plane).
# - Loads /tmp/portal-runtime.env (generated by portal-agent.sh)
# - Creates ipsets for allowed MACs (per role/profile)
# - Installs iptables rules:
#     * DNS hijack (PREROUTING/nat) for unauthorized clients
#     * Forwarding gate (filter) allowing:
#         - authorized MACs
#         - traffic to portal/controller IPs
#
# Logs are written to syslog and can be read via:
#   logread -e portal-fw
# =========================================================

set -eu

RUNTIME_ENV="${RUNTIME_ENV:-/tmp/portal-runtime.env}"
LOG_TAG="${LOG_TAG:-portal-fw}"

# Defaults (used if runtime env is missing/partial)
LAN_IF="${LAN_IF:-br-lan}"
PORTAL_IP="${PORTAL_IP:-192.168.16.118}"
DNS_PORT="${DNS_PORT:-53}"

# ipset names (may be overridden by runtime env)
IPSET_GUEST="${IPSET_GUEST:-portal_allow_guest}"
IPSET_STAFF="${IPSET_STAFF:-portal_allow_staff}"
IPSET_BYPASS_MAC="${IPSET_BYPASS_MAC:-portal_bypass_mac}"
IPSET_BYPASS_IP="${IPSET_BYPASS_IP:-portal_bypass_ip}"
IPSET_BYPASS_DNS="${IPSET_BYPASS_DNS:-portal_bypass_dns}"

# chains
CHAIN_DNS="${CHAIN_DNS:-PORTAL_DNS}"
CHAIN_FWD="${CHAIN_FWD:-PORTAL_FWD}"

log() { logger -t "$LOG_TAG" "$*"; }

# Load runtime env (generated on ImmortalWRT by portal-agent.sh)
if [ -f "$RUNTIME_ENV" ]; then
  # shellcheck disable=SC1090
  . "$RUNTIME_ENV" || true
fi

# Ensure variables exist after sourcing
LAN_IF="${LAN_IF:-br-lan}"
PORTAL_IP="${PORTAL_IP:-192.168.16.118}"
DNS_PORT="${DNS_PORT:-53}"
IPSET_GUEST="${IPSET_GUEST:-portal_allow_guest}"
IPSET_STAFF="${IPSET_STAFF:-portal_allow_staff}"
IPSET_BYPASS_MAC="${IPSET_BYPASS_MAC:-portal_bypass_mac}"
IPSET_BYPASS_IP="${IPSET_BYPASS_IP:-portal_bypass_ip}"
IPSET_BYPASS_DNS="${IPSET_BYPASS_DNS:-portal_bypass_dns}"

log "event=init_start lan_if=${LAN_IF} portal_ip=${PORTAL_IP} dns_port=${DNS_PORT}"

# ---------------------------------------------------------
# 1) ipsets: Function to create a MAC-based ipset with version compatibility
# ---------------------------------------------------------
ensure_ipset_mac() {
  name="$1"

  # Check if ipset already exists. This avoids redundancy and simplifies the logic.
  if ipset list "$name" >/dev/null 2>&1; then
    log "event=ipset_exists name=${name}"
    return 0
  fi

  log "event=ipset_creating name=${name} type=hash:mac"

  # --- Compatibility Attempts (Try newest syntax first, fall back) ---

  # 1. Attempt using ipset v7.x compliant syntax (Option: timeout, Value: 0).
  # 'timeout 0' sets the default timeout to 0 (permanent), but critically enables
  # per-entry timeout handling for later 'ipset add' commands in portal-agent.sh.
  # This specifically fixes the 'Missing mandatory argument' error.
  if ipset create "$name" hash:mac timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v7.x_compliant"
    return 0
  fi

  # 2. Fallback: Attempt using ipset v6.x syntax (Option: --timeout, Value: 0).
  # Some older versions of ipset require the -- prefix for create options.
  if ipset create "$name" hash:mac --timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v6.x_compliant"
    return 0
  fi

  # 3. Last Fallback: Attempt creating the set without any timeout option.
  # This provides basic MAC filtering functionality for very old ipset versions
  # that might not support the timeout extension at all.
  if ipset create "$name" hash:mac 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=no_timeout"
    return 0
  fi

  # If all attempts fail, log a critical error and exit the script.
  log "error=ipset_create_failed name=${name} msg='All ipset creation attempts failed. Check ipset version/support.'"
  exit 1
}

# Create an IP-based ipset (hash:ip)
ensure_ipset_ip() {
  name="$1"

  if ipset list "$name" >/dev/null 2>&1; then
    log "event=ipset_exists name=${name}"
    return 0
  fi

  log "event=ipset_creating name=${name} type=hash:ip"

  if ipset create "$name" hash:ip timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v7.x_compliant"
    return 0
  fi

  if ipset create "$name" hash:ip --timeout 0 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=v6.x_compliant"
    return 0
  fi

  if ipset create "$name" hash:ip 2>/dev/null; then
    log "event=ipset_created name=${name} syntax=no_timeout"
    return 0
  fi

  log "error=ipset_create_failed name=${name} type=hash:ip"
  exit 1
}

assert_ipset_hash_ip() {
  name="$1"
  if ipset list "$name" >/dev/null 2>&1; then
    if ! ipset list "$name" | grep -q "Type: hash:ip"; then
      log "level=error event=ipset_type_mismatch name=${name} expect=hash:ip"
      exit 1
    fi
  fi
}

# normalize_domain
#
# Normalize domain names for dnsmasq ipset rules.
#
# Why this is required:
# - dnsmasq ipset uses suffix matching, NOT glob patterns
# - "*.example.com" is WRONG for dnsmasq
# - Correct form is "example.com"
#
# This function:
# - trims leading/trailing whitespace
# - strips leading "*." (glob-style wildcard)
# - strips leading "." (common misconfiguration)
# - returns empty string for invalid input
#
# Examples:
#   "*.microsoft.com" -> "microsoft.com"
#   ".apple.com"      -> "apple.com"
#   "google.com"      -> "google.com"
#
normalize_domain() {
  d="$1"

  # trim whitespace
  d="$(echo "$d" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

  # strip leading "*."
  d="${d#*.}"

  # strip leading "."
  d="${d#.}"

  # basic sanity check (must contain at least one dot)
  case "$d" in
    *.*) echo "$d" ;;
    *)   echo "" ;;
  esac
}

ensure_ipset_mac "$IPSET_GUEST"
ensure_ipset_mac "$IPSET_STAFF"
ensure_ipset_mac "$IPSET_BYPASS_MAC"
ensure_ipset_ip  "$IPSET_BYPASS_IP"
ensure_ipset_ip  "$IPSET_BYPASS_DNS"   # Domains are ultimately resolved to IPs
assert_ipset_hash_ip "$IPSET_BYPASS_DNS"

# ---------------------------------------------------------
# 1.0) Always bypass self MAC (bridge MAC) to avoid locking out the router itself
# ---------------------------------------------------------
SELF_MAC="$(cat /sys/class/net/"${LAN_IF}"/address 2>/dev/null || true)"
if [ -n "$SELF_MAC" ]; then
  ipset -exist add "$IPSET_BYPASS_MAC" "$SELF_MAC" timeout 0 || true
  log "event=bypass_self_mac mac=${SELF_MAC}"
fi

# ---------------------------------------------------------
# 1.1) Bypass MACs from controller (JSON array)
# ---------------------------------------------------------
if [ "${BYPASS_ENABLED:-false}" = "true" ] && [ -n "${BYPASS_MACS:-}" ]; then
  if echo "$BYPASS_MACS" | jq -e 'type=="array"' >/dev/null 2>&1; then
    echo "$BYPASS_MACS" | jq -r '.[]' | while read -r mac; do
      [ -n "$mac" ] || continue
      ipset -exist add "$IPSET_BYPASS_MAC" "$mac" timeout 0 || true
      log "event=bypass_ctrl_mac mac=${mac}"
    done
  else
    log "level=error event=bypass_macs_parse_failed raw=${BYPASS_MACS}"
  fi
fi

# ---------------------------------------------------------
# 1.2) Bypass IPs from controller (JSON array)
# ---------------------------------------------------------
if [ "${BYPASS_ENABLED:-false}" = "true" ] && [ -n "${BYPASS_IPS:-}" ]; then
  if echo "$BYPASS_IPS" | jq -e 'type=="array"' >/dev/null 2>&1; then
    echo "$BYPASS_IPS" | jq -r '.[]' | while read -r ip; do
      [ -n "$ip" ] || continue
      ipset -exist add "$IPSET_BYPASS_IP" "$ip" timeout 0 || true
      log "event=bypass_ctrl_ip ip=${ip}"
    done
  else
    log "level=error event=bypass_ips_parse_failed raw=${BYPASS_IPS}"
  fi
fi

# ---------------------------------------------------------
# 1.3) Bypass domains via dnsmasq -> ipset (OpenWrt correct way)
# ---------------------------------------------------------
if [ "${BYPASS_ENABLED:-false}" = "true" ] && [ -n "${BYPASS_DOMAINS:-}" ]; then
  if echo "$BYPASS_DOMAINS" | jq -e 'type=="array"' >/dev/null 2>&1; then
    DNSMASQ_IPSET_DIR="/tmp/dnsmasq.d"
    DNSMASQ_IPSET_CONF="${DNSMASQ_IPSET_DIR}/portal-bypass-ipset.conf"

    mkdir -p "$DNSMASQ_IPSET_DIR"
    : > "$DNSMASQ_IPSET_CONF"

    echo "$BYPASS_DOMAINS" | jq -r '.[]' | while read -r raw; do
      [ -n "$raw" ] || continue

      domain="$(normalize_domain "$raw")"
      [ -n "$domain" ] || continue

      echo "ipset=/${domain}/${IPSET_BYPASS_DNS}" >> "$DNSMASQ_IPSET_CONF"
      log "event=bypass_ctrl_domain domain=${domain}"
    done

    if [ -s "$DNSMASQ_IPSET_CONF" ]; then
      if /etc/init.d/dnsmasq reload 2>/dev/null; then
        log "event=dnsmasq_reloaded reason=bypass_domains"
      elif /etc/init.d/dnsmasq restart 2>/dev/null; then
        log "event=dnsmasq_restarted reason=bypass_domains"
      else
        log "level=error event=dnsmasq_reload_failed reason=bypass_domains"
      fi
    else
      log "event=dnsmasq_skip reason=no_valid_bypass_domains"
    fi
  else
    log "level=error event=bypass_domains_parse_failed raw=${BYPASS_DOMAINS}"
  fi
fi

# ---------------------------------------------------------
# 2) NAT: DNS hijack chain
# ---------------------------------------------------------
if ! iptables -t nat -L "$CHAIN_DNS" >/dev/null 2>&1; then
  iptables -t nat -N "$CHAIN_DNS"
  log "event=chain_created table=nat chain=${CHAIN_DNS}"
fi

# Hook PREROUTING -> CHAIN_DNS (LAN only)
if ! iptables -t nat -C PREROUTING -i "$LAN_IF" -j "$CHAIN_DNS" >/dev/null 2>&1; then
  iptables -t nat -I PREROUTING 1 -i "$LAN_IF" -j "$CHAIN_DNS"
  log "event=chain_hooked table=nat hook=PREROUTING chain=${CHAIN_DNS} in=${LAN_IF}"
fi

# Rebuild rules
iptables -t nat -F "$CHAIN_DNS"

# Authorized clients (any allow ipset) -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_GUEST" src -j RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_STAFF" src -j RETURN

# Bypass MACs -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_BYPASS_MAC" src -j RETURN
# Bypass IPs -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_BYPASS_IP" dst -j RETURN
# Bypass Domains -> RETURN
iptables -t nat -A "$CHAIN_DNS" -m set --match-set "$IPSET_BYPASS_DNS" dst -j RETURN

# Hijack DNS to portal IP
iptables -t nat -A "$CHAIN_DNS" -p udp --dport 53 -j DNAT --to-destination "${PORTAL_IP}:${DNS_PORT}"
iptables -t nat -A "$CHAIN_DNS" -p tcp --dport 53 -j DNAT --to-destination "${PORTAL_IP}:${DNS_PORT}"

iptables -t nat -A "$CHAIN_DNS" -j RETURN
log "event=dns_rules_installed chain=${CHAIN_DNS}"

# ---------------------------------------------------------
# 3) FILTER: forwarding control chain
# ---------------------------------------------------------
if ! iptables -L "$CHAIN_FWD" >/dev/null 2>&1; then
  iptables -N "$CHAIN_FWD"
  log "event=chain_created table=filter chain=${CHAIN_FWD}"
fi

# Hook lan forwarding custom chain (fw3) -> CHAIN_FWD
# (Your fw3 chain already exists: forwarding_lan_rule)
if ! iptables -C forwarding_lan_rule -j "$CHAIN_FWD" >/dev/null 2>&1; then
  iptables -I forwarding_lan_rule 1 -j "$CHAIN_FWD"
  log "event=chain_hooked table=filter hook=forwarding_lan_rule chain=${CHAIN_FWD}"
fi

iptables -F "$CHAIN_FWD"

# Allow authorized MACs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_GUEST" src -j ACCEPT
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_STAFF" src -j ACCEPT

# Allow bypass MACs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_BYPASS_MAC" src -j ACCEPT
# Allow bypass IPs
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_BYPASS_IP" dst -j ACCEPT
# Allow bypass Domains
iptables -A "$CHAIN_FWD" -m set --match-set "$IPSET_BYPASS_DNS" dst -j ACCEPT


# Always allow reaching portal/controller IP (for login/heartbeat)
iptables -A "$CHAIN_FWD" -d "$PORTAL_IP" -j ACCEPT

# Block everything else
iptables -A "$CHAIN_FWD" -j REJECT --reject-with icmp-port-unreachable

log "event=init_done"
exit 0