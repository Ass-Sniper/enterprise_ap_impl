#!/bin/sh
# =========================================================
# ImmortalWRT Portal Sync (MAC -> ipset)
#
# Runs on ImmortalWRT (data-plane).
# - Collects active MACs from 3 sources:
#     * DHCP leases (/tmp/dhcp.leases)     source=dhcp
#     * ARP/neigh table (ip neigh)        source=arp
#     * Bridge FDB (brctl showmacs)       source=fdb
# - Calls ap-controller batch API to get authorization + remaining TTL
# - Updates per-role ipsets with TTL-aware entries
# - Implements "minimum survival threshold": remove only after N consecutive misses
# - Optional: heartbeat linkage to extend sessions (controller-side)
#
# Logs to syslog:
#   logread -e portal-sync
# =========================================================

set -eu

TAG="portal-sync"

# Runtime env generated by portal-agent.sh
RUNTIME_ENV="${RUNTIME_ENV:-/tmp/portal-runtime.env}"

# Controller base (fallback if runtime env missing)
CTRL_BASE_DEFAULT="${CTRL_BASE_DEFAULT:-http://192.168.16.118:8443}"
CTRL_BASE="$CTRL_BASE_DEFAULT"

# New Go endpoints (preferred) + legacy fallback
BATCH_STATUS_PATH="${BATCH_STATUS_PATH:-/api/v1/session/batch_status}"
BATCH_STATUS_LEGACY_PATH="${BATCH_STATUS_LEGACY_PATH:-/portal/batch_status}"

BATCH_HEARTBEAT_PATH="${BATCH_HEARTBEAT_PATH:-/api/v1/session/batch_heartbeat}"
HEARTBEAT_LEGACY_PATH="${HEARTBEAT_LEGACY_PATH:-/portal/heartbeat}"

# Data-plane (fallback)
LAN_IF="${LAN_IF:-br-lan}"

# ipsets (fallback)
IPSET_GUEST="${IPSET_GUEST:-portal_allow_guest}"
IPSET_STAFF="${IPSET_STAFF:-portal_allow_staff}"
IPSET_BYPASS="${IPSET_BYPASS:-portal_bypass_mac}"

# State file for "N-miss" offline threshold
STATE_FILE="${STATE_FILE:-/tmp/portal-sync.state}"
MISS_THRESHOLD="${MISS_THRESHOLD:-3}"

# TTL strategy per source (seconds, 0 means "use controller ttl")
TTL_MAX_DHCP="${TTL_MAX_DHCP:-0}"
TTL_MAX_ARP="${TTL_MAX_ARP:-300}"
TTL_MAX_FDB="${TTL_MAX_FDB:-120}"

# Whether to send heartbeat for authorized clients (0/1)
ENABLE_HEARTBEAT="${ENABLE_HEARTBEAT:-1}"

# -------- utils --------
log() { logger -t "$TAG" "$*"; }

# load runtime env
if [ -f "$RUNTIME_ENV" ]; then
  # shellcheck disable=SC1090
  . "$RUNTIME_ENV" || true
fi

CTRL_BASE="${CTRL_BASE:-$CTRL_BASE_DEFAULT}"
LAN_IF="${LAN_IF:-br-lan}"

# Ensure ipsets exist (portal-fw.sh should do it, but be defensive)
ensure_ipset() {
  name="$1"
  ipset list "$name" >/dev/null 2>&1 || ipset create "$name" hash:mac timeout || true
}
ensure_ipset "$IPSET_GUEST"
ensure_ipset "$IPSET_STAFF"
ensure_ipset "$IPSET_BYPASS"

# Always bypass self MAC (avoid locking router out)
SELF_MAC="$(cat /sys/class/net/${LAN_IF}/address 2>/dev/null || true)"
if [ -n "$SELF_MAC" ]; then
  ipset -exist add "$IPSET_BYPASS" "$SELF_MAC" timeout 0 || true
fi

# Normalize MAC to lower
norm_mac() {
  echo "$1" | tr 'A-F' 'a-f'
}

# Pick TTL by source (cap)
cap_ttl() {
  ttl="$1"
  src="$2"
  [ -n "$ttl" ] || ttl="0"
  case "$src" in
    dhcp) cap="$TTL_MAX_DHCP" ;;
    arp)  cap="$TTL_MAX_ARP" ;;
    fdb)  cap="$TTL_MAX_FDB" ;;
    *)    cap="0" ;;
  esac
  if [ "$cap" -gt 0 ] && [ "$ttl" -gt "$cap" ]; then
    echo "$cap"
  else
    echo "$ttl"
  fi
}

# -----------------------
# 1) Collect MACs (DHCP/ARP/FDB) and assign a best source
#    precedence: dhcp > arp > fdb
# -----------------------
TMP_DIR="/tmp/portal-sync.$$"
mkdir -p "$TMP_DIR"
MAC_SRC_FILE="$TMP_DIR/macs.txt"      # "mac source"
MAC_ONLY_FILE="$TMP_DIR/macs_only.txt"

collect_dhcp() {
  LEASE_FILE="/tmp/dhcp.leases"
  [ -f "$LEASE_FILE" ] || return 0
  awk 'NF>=2 {print tolower($2)" dhcp"}' "$LEASE_FILE" 2>/dev/null || true
}

collect_arp() {
  # Filter: only lines containing "lladdr <mac>" and NOT FAILED
  # States we accept: REACHABLE, STALE, DELAY, PROBE (and others that still have lladdr)
  ip neigh show dev "$LAN_IF" 2>/dev/null \
    | awk '
      /lladdr/ && $0 !~ / FAILED$/ {
        for (i=1;i<=NF;i++) if ($i=="lladdr") {print tolower($(i+1))" arp"; break}
      }'
}

collect_fdb() {
  # brctl output: portno mac is_local? age
  # We ignore is_local=1 entries (bridge local MACs etc.)
  brctl showmacs "$LAN_IF" 2>/dev/null \
    | awk 'NR>1 && NF>=4 {mac=tolower($2); is_local=$3; if (is_local!="yes" && is_local!="1") print mac" fdb"}' \
    || true
}

# Merge sources with precedence
# We store best source for each mac.
{
  collect_fdb
  collect_arp
  collect_dhcp
} | awk '
  {
    mac=$1; src=$2
    if (mac=="" || mac=="00:00:00:00:00:00") next
    # precedence: fdb(1) < arp(2) < dhcp(3)
    p=(src=="fdb")?1:(src=="arp")?2:(src=="dhcp")?3:0
    if (!(mac in bestp) || p>bestp[mac]) { bestp[mac]=p; bests[mac]=src }
  }
  END { for (m in bests) print m" "bests[m] }
' >"$MAC_SRC_FILE"

awk '{print $1}' "$MAC_SRC_FILE" | sort -u >"$MAC_ONLY_FILE"
SEEN_COUNT="$(wc -l <"$MAC_ONLY_FILE" 2>/dev/null || echo 0)"

# -----------------------
# 2) Load/Update miss counters
# -----------------------
# STATE_FILE format: "mac miss_count"
touch "$STATE_FILE" 2>/dev/null || true

# mark all previous as missed by default; then reset for seen
# We'll build new state in tmp and mv.
NEW_STATE="$TMP_DIR/state.new"

# Build a set of seen macs for awk
# Busybox awk: use associative array.
awk -v seenfile="$MAC_ONLY_FILE" -v thresh="$MISS_THRESHOLD" '
  BEGIN {
    while ((getline < seenfile) > 0) { seen[$1]=1 }
    close(seenfile)
  }
  # read old state from stdin
  {
    mac=$1; miss=$2
    if (mac=="" ) next
    if (mac in seen) {
      miss=0
      keep[mac]=1
    } else {
      miss=(miss==""?0:miss)+1
      keep[mac]=1
    }
    state[mac]=miss
  }
  END {
    # include new seen macs not in old state
    for (m in seen) if (!(m in state)) state[m]=0
    for (m in state) print m" "state[m]
  }
' "$STATE_FILE" >"$NEW_STATE" || true

mv -f "$NEW_STATE" "$STATE_FILE"

# Determine which macs should be considered "active" vs "offline"
# active: miss < thresh
ACTIVE_FILE="$TMP_DIR/active.txt"
OFFLINE_FILE="$TMP_DIR/offline.txt"

awk -v thresh="$MISS_THRESHOLD" '
  { mac=$1; miss=$2; if (miss<thresh) print mac > "'"$ACTIVE_FILE"'"; else print mac > "'"$OFFLINE_FILE"'" }
' "$STATE_FILE" 2>/dev/null || true

ACTIVE_COUNT="$(wc -l <"$ACTIVE_FILE" 2>/dev/null || echo 0)"
OFFLINE_COUNT="$(wc -l <"$OFFLINE_FILE" 2>/dev/null || echo 0)"

# -----------------------
# 3) Batch query controller for ACTIVE macs
# -----------------------
# Build JSON entries: [{"mac":"..","source":"dhcp"}, ...]
ENTRIES_JSON="$TMP_DIR/entries.json"
{
  echo -n '{"policy_version":"'"${POLICY_VERSION:-0}"'","ap_id":"'"${AP_ID:-unknown}"'","entries":['
  first=1
  while read -r mac; do
    [ -n "$mac" ] || continue
    src="$(awk -v m="$mac" '$1==m{print $2; exit}' "$MAC_SRC_FILE")"
    [ -n "$src" ] || src="arp"
    if [ $first -eq 1 ]; then first=0; else echo -n ','; fi
    echo -n '{"mac":"'"$mac"'","source":"'"$src"'"}'
  done <"$ACTIVE_FILE"
  echo ']}'
} >"$ENTRIES_JSON"

post_json() {
  url="$1"
  bodyfile="$2"
  curl -fsS --max-time 4 -H 'Content-Type: application/json' -d @"$bodyfile" "$url"
}

RESP="$(post_json "${CTRL_BASE}${BATCH_STATUS_PATH}" "$ENTRIES_JSON" 2>/dev/null || true)"
if [ -z "$RESP" ]; then
  RESP="$(post_json "${CTRL_BASE}${BATCH_STATUS_LEGACY_PATH}" "$ENTRIES_JSON" 2>/dev/null || true)"
fi

if [ -z "$RESP" ]; then
  log "event=batch_status_failed ctrl=${CTRL_BASE} active=${ACTIVE_COUNT}"
  # Still perform offline removals based on miss threshold
  :
fi

# -----------------------
# 4) Apply ipset updates
# -----------------------
SCANNED=0
ALLOWED=0
REFRESHED=0
REMOVED=0
HEARTBEATED=0

# helper: add/update in specific ipset with ttl
ipset_upsert() {
  setname="$1"
  mac="$2"
  ttl="$3"
  if [ "$ttl" -le 0 ]; then
    # ttl<=0 means do not install into allow set
    return 1
  fi
  ipset -exist add "$setname" "$mac" timeout "$ttl" >/dev/null 2>&1 || true
  return 0
}

# Remove from both allow sets
ipset_remove_all() {
  mac="$1"
  ipset del "$IPSET_GUEST" "$mac" >/dev/null 2>&1 || true
  ipset del "$IPSET_STAFF" "$mac" >/dev/null 2>&1 || true
}

# offline removals (N-miss)
while read -r mac; do
  [ -n "$mac" ] || continue
  ipset_remove_all "$mac"
  REMOVED=$((REMOVED + 1))
done <"$OFFLINE_FILE" 2>/dev/null || true

# If controller responded, iterate results
if [ -n "$RESP" ]; then
  # Determine array key: results or results[]
  # We'll count results by probing indexes until empty.
  i=0
  while :; do
    mac="$(printf '%s' "$RESP" | jsonfilter -e "@.results[$i].mac" 2>/dev/null || true)"
    [ -n "$mac" ] || break
    SCANNED=$((SCANNED + 1))

    authorized="$(printf '%s' "$RESP" | jsonfilter -e "@.results[$i].authorized" 2>/dev/null || true)"
    role="$(printf '%s' "$RESP" | jsonfilter -e "@.results[$i].role" 2>/dev/null || true)"
    ttl="$(printf '%s' "$RESP" | jsonfilter -e "@.results[$i].ttl" 2>/dev/null || true)"
    ipset_name="$(printf '%s' "$RESP" | jsonfilter -e "@.results[$i].ipset" 2>/dev/null || true)"
    src="$(awk -v m="$mac" '$1==m{print $2; exit}' "$MAC_SRC_FILE")"
    [ -n "$src" ] || src="arp"

    # Normalize
    mac="$(norm_mac "$mac")"
    ttl="${ttl:-0}"
    [ "$ttl" -ge 0 ] 2>/dev/null || ttl=0

    # Unauthorized or ttl invalid => remove
    if [ "$authorized" != "true" ] || [ "$ttl" -le 0 ]; then
      ipset_remove_all "$mac"
      REMOVED=$((REMOVED + 1))
      i=$((i + 1))
      continue
    fi

    # Apply source TTL policy (cap)
    ttl="$(cap_ttl "$ttl" "$src")"

    # Decide target ipset (prefer controller response; fallback by role)
    target="$ipset_name"
    if [ -z "$target" ] || [ "$target" = "null" ]; then
      case "$role" in
        staff) target="$IPSET_STAFF" ;;
        *)     target="$IPSET_GUEST" ;;
      esac
    fi

    # Ensure target exists
    ensure_ipset "$target"

    # Upsert and cleanup from other allow set if role changed
    if ipset_upsert "$target" "$mac" "$ttl"; then
      ALLOWED=$((ALLOWED + 1))
      REFRESHED=$((REFRESHED + 1))
      if [ "$target" = "$IPSET_GUEST" ]; then
        ipset del "$IPSET_STAFF" "$mac" >/dev/null 2>&1 || true
      elif [ "$target" = "$IPSET_STAFF" ]; then
        ipset del "$IPSET_GUEST" "$mac" >/dev/null 2>&1 || true
      fi
    fi

    i=$((i + 1))
  done
fi

# -----------------------
# 5) Optional heartbeat linkage (best-effort)
# -----------------------
if [ "$ENABLE_HEARTBEAT" = "1" ] && [ "$ACTIVE_COUNT" -gt 0 ]; then
  # Prefer batch heartbeat (Go), fallback to legacy per-mac heartbeat is too slow; we skip if batch is missing.
  HB_BODY="$TMP_DIR/hb.json"
  {
    echo -n '{"policy_version":"'"${POLICY_VERSION:-0}"'","ap_id":"'"${AP_ID:-unknown}"'","entries":['
    first=1
    while read -r mac; do
      [ -n "$mac" ] || continue
      src="$(awk -v m="$mac" '$1==m{print $2; exit}' "$MAC_SRC_FILE")"
      [ -n "$src" ] || src="arp"
      if [ $first -eq 1 ]; then first=0; else echo -n ','; fi
      echo -n '{"mac":"'"$mac"'","source":"'"$src"'"}'
    done <"$ACTIVE_FILE"
    echo ']}'
  } >"$HB_BODY"

  HB_RESP="$(post_json "${CTRL_BASE}${BATCH_HEARTBEAT_PATH}" "$HB_BODY" 2>/dev/null || true)"
  if [ -n "$HB_RESP" ]; then
    HEARTBEATED="$ACTIVE_COUNT"
  else
    # If no batch endpoint, try nothing (avoid per-mac storm)
    HEARTBEATED=0
  fi
fi

log "event=sync_done policy_version=${POLICY_VERSION:-0} seen=${SEEN_COUNT} active=${ACTIVE_COUNT} offline=${OFFLINE_COUNT} scanned=${SCANNED} allowed=${ALLOWED} refreshed=${REFRESHED} removed=${REMOVED} heartbeated=${HEARTBEATED}"

rm -rf "$TMP_DIR" >/dev/null 2>&1 || true
exit 0